# りあくと第３版vol1まとめ
## 第1章 こんにちはReact
### 1-1. 基本環境の構築 
* 「Node.js は簡単にいうと、JavaScript をのPC のターミナル上で動かすことができるようにするためのソフトウェア
    * ファイルのバンドル
    * jsコードを最初にコンパイル
    * ローカルサーバ
    * テスト
* node.jsインストール
    * homebrew(Mac OS用のパッケージマネージャ)が楽だがバージョンマネージャを使うことを推奨
        * Homebrew > anyenv > Node
* `anyenv update`で、Nodeを最新版にアップデートする前はこれを実行して、インストール可能なリストを更新する
* npmはフロントエンドとバックエンド用のパッケージ管理ツール
    * npm 公式リポジトリ（npmjs.com）で提供されているパッケージの追加・更新・削除に加えて、各パッケージ間のバージョン整合とかも自動的にやってくれる 
* YarnはFacebook 製の改良版npmコマンド
    - 高速で簡潔な記述なので人気

### 1-2. プロジェクトを作成する
* `Create React App`
    - コマンド一つでプロジェクトのスケルトンが作られる
    - ３つのパッケージがインストールされる
        - react
            - react本体
        - react-dom
            - DOMをReactから操作できるようにする
        - react-scripts
            - その他もろもろ
            - Babel
            - webpack
            - webpack-dev-server
            - Jest
            - テスト
            - 環境変数の設定(dotenv)
            - PWA化
    - `$ npx create-react-app hello-world --template typescript`
- Reactの基本概念
    - reactアプリケーションはすべてコンポーネントの組み合わせ
        - コンポーネント>任意のUIを表現するパーツの単位
        - 大文字からはじめる命名規則
    - コンポーネントインポート時の拡張子は省略可能
    - コンポーネントは関数またはクラスで定義する
    - ReactオブジェクトをインポートすることでJSXの記述が可能になる
- CRAで作成したプロジェクトではソースファイルはBabelがコンパイルし、バンドラであるwebpackが適切な形にまとめ相互に関連付けられる

### 1-3. アプリを管理するためのコマンドやスクリプト
- CRAで生成したプロジェクトはデフォルトでyarnが指定されている
    - npmが良ければ`--use--npm`オプションを`create-react-app`につける
- appの実行には参照するnpmのパッケージモジュール(`node_modules/`)のインストールが必要
    - `yarn install`
- その他yarn頻出コマンド
    - `yarn add <PACKAGE_NAME>` …………指定したパッケージをインストールする
    - `yarn remove <PACKAGE_NAME>` …………指定したパッケージをアンインストールする
    - `yarn upgrade <PACKAGE_NAME>` …………指定したパッケージを最新バージョンに更新する
    - `yarn info <PACKAGE_NAME>` …………指定したパッケージについての情報を表示する
- パッケージ情報はルートディレクトリの`package.json`に記述される
- package.jsonはインストールするべきバージョン番号が指定されている
    - `yarn install`で実行される内容を保証するわけではない
    - メンバー間でバージョンが異なると挙動が変わったり本番環境のトラブルになる
    - `yarn lock`にパッケージの各依存関係のどのバージョンがインストールされたかが正確に記録されている
        - 削除しないように
        - `yarn lock`の内容をバックデートすると問題が解決することがある
    - `yarn upgrade-interactive [--latest]`
        - `package.json` に記述してある各パッケージのバージョン範囲にしたがって、すべてのインストールしてあるパッケージの更新情報をチェック、対話形式で一括アップデートできるコマンド
        - `--latest` オプションを指定すると、`package.json` に記述されてるバージョン範囲を無視して最新の安定版バージョンに一括アップデートできる
        - このコマンドで動かなくなった場合はいったん`package.json`や`yarn.lock`を元に戻す
- npm-scripts
    - `package.json`の中のscripts エントリに実行させたい処理コマンドを記述してリストに入れておくと、あたかもnpm コマンドやYarn コマンドのように実行できる
    - エイリアスとしての用途が多いが、予約キーワードがいくつか存在することは知っておく
    - `yarn start`でアプリを起動するときは専用のターミナルアプリじゃなくVSCode にターミナルの機能推奨
        - エラーがあったとき、指摘部分をcommand + 左クリックで該当ファイルが開いたりと色々と便利
- react-scripts
    - 実体は`node_modules/react-scripts/scripts/` ディレクトリ内
    - `package.json` のscripts エントリで設定されてるreact-scripts の実行に一対一で対応
        - `start`>ローカルで開発用のHTTP サーバを起動してそこでアプリを稼働させるコマンド
        - `build`>本番環境にデプロイするためのファイルを作成するコマンド。これを実行すると、プロジェクトルートに`build/` ディレクトリが作られ、その中に一連のビルド済みファイルが展開される
        - `test` ソースディレクトリからテストファイルを抽出してテストを走らせる
            - 起動したままにしておくと、テストファイルの差分を検知して、変更のあったテストだけが実行される
        - `eject` react-scriptsの設定の依存関係を解除する
            - 上級者向けでリソースを食うので基本使わない

## 第2章 エッジでディープなJavaScriptの世界
### 2-1. あらためてJavaScriptってどんな言語？
- TypeScript はJavaScript に静的型付けによる拡張された型システムを加えた上位互換の言語
### 2-2. 変数の宣言
- varの問題点
    1. 再宣言可能
    2. 変数の参照巻き上げ
    3. スコープ単位が関数
- varは使わない
- 第一候補はconstで再代入が必要な場合はlet
### 2-3. JavaScriptのデータ型
- 静的型付け言語と動的型付け言語
    - 静的型付け言語は変数や、関数の引数および戻り値の型がプログラムの実行前にあらかじめ決まってなければいけない
    - 、動的型付け言語ではそれらが実行時の値によって文字通り動的に変化する
- JSはデータ型がプリミティブ型とオブジェクト型に分かれる
#### JavaScript におけるプリミティブ型
#### プリミティブ値のリテラルとラッパーオブジェクト
- null とundefined を除くすべてのプリミティブ型には、それらの値を抱合する『ラッパーオブジェクト（Wrapper Object）』が存在。
    - string型>String
    - number型>Number
- JavaScript には、プリミティブ型の値に対してアクセスするとき、その対応するラッパーオ
ブジェクトに自動変換するという仕様があるため、結果的にインスタンスメソッドが使える
#### オブジェクト型とそのリテラル 
- JSには広義のオブジェクトと狭義のオブジェクトの2種類がある
    - 狭義>キーと値を持ったプロパティの集まり
    - 広義>プリミティブ値以外
### 2-4. 関数の定義 
#### 関数宣言と関数式
- 文と式の違い
    - 文:何らかの手続を処理系に命令するもの(変数に代入できない)
        - 文の末尾には`;`が必要だが`{}`で終わる場合は例外的に不要
    - 式:評価されたあとに値として存在するもの(変数に代入できる)
- 関数式による定義は`;`が必要
    ```JavaScript
    // 関数宣言文による定義
    function double(n) {
    return n * 2;
    }
    // 関数式による定義
    const twice = function (n) {
    return n * 2;
    }; 
    ```
    - 巻き上げを回避するため関数式を推奨
- JSでは関数はビルトインオブジェクト`Function`のインスタンスであり「第一級オブジェクト」
    - 他のオブジェクト型と同様に変数への代入、配列の要素やオブジェクトのプロパティにしたり他の関数の引数や戻り値に設定できること
- オブジェクトのプロパティとなっている関数をメソッドと呼ぶ

#### アロー関数式と無名関数
- 無名関数>関数を生成した上でそれを変数に代入することによってメモリ上に残してる
- アロー関数推奨

#### さまざまな引数の表現
- デフォルト引数
    ``` Javascript
    const raise = (n, m = 2) => n ** m;
    console.log(raise(2, 3)); // 8
    console.log(raise(3)); // 9
    ```
    - デフォルト値が設定された引数は省略可能で、省略するとその値が適用
    - デフォルト値の設定がある引数はいちばん後ろから置いていく(重要な引数を先頭におくべき)
- Rest Parameters
    - `...`をつけることで残りの引数を配列として受け取る

### 2-5. クラスを表現する
- メンバーメソッドはできるだけアロー関数を使うのがおすすめ

#### クラスのようでクラスでない、JavaScriptのクラス構文
- RubyやJavaは「クラスベース」のオブジェクト指向言語だがJSは「プロトタイプベース」

#### プロトタイプベースのオブジェクト指向とは 
- プロトタイプベースでは、そもそもオブジェクトの抽象としてのクラスが存在しない。オブジェクトは直接、他のオブジェクトを継承する。そのときの継承元になったオブジェクトのことを『プロトタイプ』と呼ぶ
- クラスは実体がない抽象概念だがプロトタイプは実体のあるオブジェクト
- コンストラクタ関数は、それぞれに設定されているプロトタイプオブジェクトを継承して、新しくオブジェクトインスタンスを生成するための関数
- プロトタイプへ直にメソッドを追加したり削除したりできる上に、その変更がすでに生成済みのインスタンスにも即時反映される

### 2-6. 配列やオブジェクトの便利な構文
#### 分割代入とスプレッド構文
``` JavaScript
//オブジェクトのキーや値を動的に設定する
const keyName = 'bar';
const baz = 65536;
const obj1 = { foo: 256, [keyName]: 4096, baz: baz };
console.log(obj1); // { foo: 256, bar: 4096, baz: 65536 }

//プロパティのショートハンド
const obj2 = { baz };
console.log(obj2); // { baz: 65536 }
```

#### オブジェクトのマージとコピー
- 破壊的なのもありオブジェクトのコピー目的に`Object.asign()`はあまり使わない
- 代わりにスプレッド構文を使う
``` JavaScript
const original = { a: 1, b: 2, c: 3 };
const copy = { ...original };
console.log(copy); // { a: 1, b: 2, c: 3 }
console.log(copy === original); // false
const assigned = { ...original, ...{ c: 10, d: 50 }, d: 100 };
console.log(assigned); // { a: 1, b: 2, c: 10, d: 100 }
console.log(original); // { a: 1, b: 2, c: 3 }
```
- いずれの場合もプロパティ値が文字列や数値はそのまま値がコピーされるけど、オブジェクトだった場合はそのオブジェクトへの参照がコピーされることに注意(シャローコピー)
    - `JSON.parse(JSON.stringify())`やLodashの`cloneDeep()`などの裏技あり

### 2-7. 式と演算子で短く書く 
#### ショートサーキット評価
- OR 演算子`||`は左辺がfalsy な値だと評価が右辺に渡される
- AND 演算子`&&`は左辺がtruthy な値のときに評価が右辺に渡される

#### ullish CoalescingとOptional Chaining
- optional chaining
    - ?. 演算子を使うと、チェーン内の各参照が正しいかどうかを明示的に確認せ
ずにアクセスしていくことができる。途中のプロパティが存在していなかったら、そこで式が短絡されてundefined を返してくれる
    - メソッドでも使える

``` JavaScript
> const obj = {};
> obj.foo
undefined
> obj.foo.bar
Uncaught TypeError: Cannot read property 'bar' of undefined
> obj?.foo?.bar
undefined
```
- nullish coalescing`??`
    - OR 演算子|| に似てるが、ちがうのは左辺がnull またはundefined のときだけ右辺が評価される。よって`0` や`''` の空文字といったfalsy な値はそのまま評価される
    - `||`は`0`や空文字をスルーしてしまうためより明示的なnullish coalescingのほうが望ましい

### 2-8. JavaScriptの鬼門、thisを理解する
#### JavaScript のthisとは何なのか 
- this とは、その関数が実行されるコンテキストであるオブジェクトへの参照が格納されている『暗黙の引数』
- JSではあらゆる関数内からthisが参照可能
    - 実行コンテキストのオブジェクトが引数this としてメソッドへ暗黙的に渡される
    - JSでの特殊な挙動として`this`を呼び出し側から任意のオブジェクトに指定して関数を実行する方法がある
        - `call(),apply()`

#### Thisの中身 4つのパターン 
- 4つの`this`
    - `new`演算子で新規生成されるオブジェクト
    - メソッドとして実行>その所属するオブジェクト
    - グローバルオブジェクト
        - メソッドではない関数、およびnew 演算子をつけずに実行されるあらゆる関数は、このグローバルオブジェクトがthis として引き渡されることになる
    - `undefined`
        - 。strictモードではグローバル汚染を防ぐため、関数がメソッドでない、任意のオブジェクトのコンテキストになかった場合`this`には`undefined`が入る

#### Thisの挙動の問題点と対処法 
- `this`を制御する対処法
    - `bind()`　引数の値をthisに固定した新しい関数を生成するメソッド 
    - `call()` 任意のオブジェクトを`this`に設定して関数を呼び出すメソッド
    - `${_this}にthisを格納する`
    - アロー関数を使う
        - アロー関数は暗黙の引数としての`this`を持たず、`this`を参照すると関数外スコープの`this`の値がそのまま使われる
    - アロー関数がクラスのインスタンスメソッドとして定義されたときだけ、内部で一時変数によるthisの移し替えが行われる
     ``` JavaScript
        greet5 = () => { // メソッド自身もアロー関数式で定義
    const doIt = () => {
        console.log(`Hi, I'm ${this.name}`);
        };
        doIt();
        }
    }
    const creamy = new Person('Mami');
    creamy.greet5(); // Hi, I'm Mami
     ```
- 推奨する運用ルール
    - `this`はクラス構文内でしか使わない
    - クラス構文内では、メソッドを含めたあらゆる関数の定義をアロー関数式で行う

### 2-9. モジュールを読み込む
#### Webpack はフロントエンド標準ビルドツールの夢を見るか？
 - モジュールバンドラの仕事
    - Minify
    - Tree Shaking
    - 画像データのインライン埋め込み
    - コード分割
    - キャッシュ管理

#### ES Modulesでインポート／エクスポート 
- node.jsの`package.json`に以下を記述
``` Javascript
{
︙
"type": "module",
```
- エクスポートには名前付きとデフォルトエクスポートがある
    - デフォルトエクスポートは読み込む側で任意の名前をつけることができる
    - 名前付きも`as`で変数名を変更可能
- npmパッケージが格納されるプロジェクトルートの`node_modules/` ディレクトリにはパスが通ってるのでパス指定は必要ない
- ES2020から複数のエクスポートを一つの名前空間に押し込め再エクスポートする
`export *as ...`が使えるようになった

## 第 3章 関数型プログラミングでいこう
### 3-1. 関数型プログラミングは何がうれしい？ 
### 3-2. コレクションの反復処理 
#### 列の反復処理 
#### ブジェクトの反復処理 
### 3-3. JavaScriptで本格関数型プログラミング 
#### らためて関数型プログラミングとは何か 
#### 階関数 
#### リー化と関数の部分適用 
#### じ込められたクロージャの秘密 
### 3-4. JavaScriptでの非同期処理
#### romise―JavaScript で非同期処理を扱う基本 
#### romiseをハンドリングする
## 第 4章 TypeScript で型をご安全に 
### 4-1. TypeScriptはイケイケの人気言語？ 
### 4-2. TypeScriptの基本的な型 
#### アノテーションと型推論 
#### avaScript と共通の型 
#### num型とリテラル型 
#### プル型 
#### ny、Unknown、Never 
### 4-3. 関数とクラスの型 
#### 数の型定義 
#### ypeScript でのクラスの扱い 
#### ラスの2つの顔 
### 4-4. 型の名前と型合成 
#### エイリアス VS インターフェース 
#### ニオン型とインターセクション型 
#### のNull 安全性を保証する 
### 4-5. さらに高度な型表現 
#### 表現に使われる演算子 
#### み込みユーティリティ型 
#### 数のオーバーロード 
### 4-6. 型アサーションと型ガード 
#### sによる型アサーション 
#### ガードでスマートに型安全を保証する 
### 4-7. モジュールと型定義 
#### ypeScript のインポート／エクスポート
#### avaScript モジュールをTypeScript から読み込む 
#### 定義ファイルはどのように探索されるか 
### 4-8. TypeScriptの環境設定 
#### ypeScript のコンパイルオプション
#### sconfig.jsonのカスタマイズ 